// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWTexture2D<float4> SandTexture;
RWTexture2D<float4> ColliderTexture;
RWStructuredBuffer<float> SandGrid;

RWStructuredBuffer<int> SandSpawnAmount;
RWStructuredBuffer<int> SandRemaining;
RWStructuredBuffer<int> SandCollected;

int width, height;
int sandSpawnX, sandSpawnY;

float4 holeX, holeY;

bool IsGridPixelEmpty(int2 pxPos) 
{
    int pxId = pxPos.y * width + pxPos.x;

    bool isPxOutsideSurfaceArea = pxId >= width * height || pxId < 0;
    if(isPxOutsideSurfaceArea) return false;

    bool isPxEmpty = SandGrid[pxId] == 0 && ColliderTexture[pxPos].w == 0;
    return isPxEmpty;
}
bool IsGridPixelCloseEmpty(int2 offset, int2 oldPos) 
{
    int2 newPos = int2(offset.x + oldPos.x, offset.y + oldPos.y);

    int newPosId = newPos.y * width + newPos.x;
    int oldPosId = oldPos.y * width + oldPos.x;

    if(newPosId >= width * height || newPosId < 0) return false;

    bool isCloseColumn = offset.x >= -1 && offset.x <= 1 && newPos.x < width && newPos.x >= 0;
    bool isCloseRow = offset.y >= -1 && offset.y <= 1 && newPos.y < height && newPos.y >= 0;

    if(!isCloseColumn || !isCloseRow) return false;

    return IsGridPixelEmpty(newPos);
}

int GetGridPixelType(int2 pxPos) 
{
    int pxId = pxPos.y * width + pxPos.x;

    return SandGrid[pxId];
}

void TrySetGridPixel(int2 pixelPos, int pixelType) 
{
    int pixelId = pixelPos.y * width + pixelPos.x;

    if(pixelId >= width * height || pixelId < 0) return;

    SandGrid[pixelId] = pixelType;
}
bool TrySetGridPixelClose(int2 offset, int2 oldPos, int pixelType) 
{
    int2 newPos = int2(offset.x + oldPos.x, offset.y + oldPos.y);

    int newPosId = (newPos.y) * width + (newPos.x);
    int oldPosId = oldPos.y * width + oldPos.x;

    bool isPixelFree = IsGridPixelCloseEmpty(offset, oldPos);
    if(isPixelFree) 
    {
        SandGrid[newPosId] = pixelType;
        return true;
    }
    else if(!isPixelFree && GetGridPixelType(newPos) == 3)
    {
        SandCollected[0] += 1;
        SandRemaining[0] -= 1;
        return true;
    }

    return false;
}

void SimulateSandPixel(int2 pxPos) 
{
    int belowId = (pxPos.y - 1) * width + pxPos.x;

    int2 topOffset = int2(0, 1);
    int2 botOffset = int2(0, -1);
    int2 leftOffset = int2(-1, 0);
    int2 rightOffset = int2(1, 0);
    int2 botLeftOffset = int2(-1, -1);
    int2 botRightOffset = int2(1, -1);

    if(TrySetGridPixelClose(botOffset, pxPos, 1)) 
    {
        TrySetGridPixel(pxPos, 0);
    }
    else if(TrySetGridPixelClose(botLeftOffset, pxPos, 1))
    {
        TrySetGridPixel(pxPos, 0);
    }
    else if(TrySetGridPixelClose(botRightOffset, pxPos, 1)) 
    {
        TrySetGridPixel(pxPos, 0);
    }
}

bool IsPixelInHole(int2 pxPos) 
{
    int botLeftX = holeX.x;
    int botRighX = holeX.y;
    int topLeftX = holeX.z;
    int topRighX = holeX.w;

    int botLeftY = holeY.x;
    int botRighY = holeY.y;
    int topLeftY = holeY.z;
    int topRighY = holeY.w;

    if(pxPos.x < botLeftX) return false;
    if(pxPos.x > botRighX) return false;
    if(pxPos.x < topLeftX) return false;
    if(pxPos.x > topRighX) return false;

    if(pxPos.y < botLeftY) return false;
    if(pxPos.y < botRighY) return false;
    if(pxPos.y > topLeftY) return false;
    if(pxPos.y > topRighY) return false;

    return true;
}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int x = (int)id.x;
    int y = (int)id.y;
    int2 xy = (int2)id.xy;

    if(x >= width || y >= height) return;

    if(ColliderTexture[xy].w != 0) 
    {
        SandGrid[y * width + x] = 2;
    }
    if(SandGrid[y* width + x] == 2) SandTexture[xy] = float4(1,0,0,1);

    int id_gridPxThis = y * width + x;
    int id_gridPxLeft = y * width + x + 1;
    int id_gridPxRight = y * width + x - 1;
    int id_gridPxTop = (y + 1) * width + x;
    int id_gridPxBot = (y - 1) * width + x;

    //Spawn sand
    if(id_gridPxThis == sandSpawnY * width + sandSpawnX && IsGridPixelEmpty(xy) && SandSpawnAmount[0] > 0) 
    {
        SandGrid[id_gridPxThis] = 1;
        SandRemaining[0] += 1;
        SandSpawnAmount[0] -= 1;
    }

    //HOLE
    if(IsPixelInHole(xy)) 
    {
        SandGrid[id_gridPxThis] = 3;
    }

    int pixelGrid = SandGrid[id_gridPxThis];
    int2 pixelTexPos = xy;

    float xPercent = (float)x / (float)width;
    float yPercent = (float)y / (float)height;

    if(pixelGrid == 1) 
    {
        //float4 sandColor = float4(xPercent, yPercent, 0, 1);
        float4 sandColor = float4(1,1,0,1);

        /*
        TrySetGridPixelClose(int2(1, 0), xy, 1);
        TrySetGridPixelClose(int2(-1, 0), xy, 1);
        TrySetGridPixelClose(int2(0, 1), xy, 1);
        TrySetGridPixelClose(int2(0, -1), xy, 1);

        TrySetGridPixel(int2(x, y), 0);
        */

        SimulateSandPixel(xy);

        SandTexture[xy] = sandColor;
    }
    else if(pixelGrid == 3) 
    {
        SandTexture[xy] = float4(0,0,0,1);
    }
    else 
    {
        SandTexture[xy] = float4(0,0,0,0);
    }
}
